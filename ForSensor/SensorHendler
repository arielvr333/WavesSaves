import smbus
import socket
from time import sleep
import multiprocessing

PWR_MGMT_1 = 0x6B
SMPLRT_DIV = 0x19
CONFIG = 0x1A
GYRO_CONFIG = 0x1B
INT_ENABLE = 0x38
ACCEL_XOUT_H = 0x3B
ACCEL_YOUT_H = 0x3D
ACCEL_ZOUT_H = 0x3F
GYRO_XOUT_H = 0x43
GYRO_YOUT_H = 0x45
GYRO_ZOUT_H = 0x47


def MPU_Init():
    bus.write_byte_data(Device_Address, SMPLRT_DIV, 7)
    bus.write_byte_data(Device_Address, PWR_MGMT_1, 1)
    bus.write_byte_data(Device_Address, CONFIG, 0)
    bus.write_byte_data(Device_Address, GYRO_CONFIG, 24)
    bus.write_byte_data(Device_Address, INT_ENABLE, 1)


def read_raw_data(addr):
    high = bus.read_byte_data(Device_Address, addr)
    low = bus.read_byte_data(Device_Address, addr + 1)
    value = ((high << 8) | low)
    if value > 32768:
        value = value - 65536
    return value


bus = smbus.SMBus(1)
Device_Address = 0x68
serverAddressPort = ("127.0.0.1", 20001)
UDPClientSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
bufferSize = 1024
UDPClientSocket.connect(serverAddressPort)

def thread_readdata(queue):
    global th
    print("Thread starting")
    while True:
        if not (queue.empty()):
            th = float(queue.get())
        acc_x = read_raw_data(ACCEL_XOUT_H)
        acc_y = read_raw_data(ACCEL_YOUT_H)
        acc_z = read_raw_data(ACCEL_ZOUT_H)
        gyro_x = read_raw_data(GYRO_XOUT_H)
        gyro_y = read_raw_data(GYRO_YOUT_H)
        gyro_z = read_raw_data(GYRO_ZOUT_H)
        Ax = acc_x / 16384.0
        Ay = acc_y / 16384.0
        Az = acc_z / 16384.0

        Gx = gyro_x / 131.0
        Gy = gyro_y / 131.0
        Gz = gyro_z / 131.0
        sleep(1)
        print(th)

        if Ax > th or Ay > th or Az > th or Gx > th or Gy > th or Gz > th:
            alert = "alert"
            bytesToSend = str.encode(alert)
            UDPClientSocket.sendto(bytesToSend, serverAddressPort)
            print(alert)


if __name__ == '__main__':

    MPU_Init()
    event = multiprocessing.Event()
    th = 3
    init = "sensor"
    bytesToSend = str.encode(init)
    UDPClientSocket.sendto(bytesToSend, serverAddressPort)
    print(init + "sent")
    queue = multiprocessing.Queue()
    queue.put(th)
    ReadingData = multiprocessing.Process(target=thread_readdata, args=(queue,))
    ReadingData.start()
    while True:
        bytesAddressPair = UDPClientSocket.recvfrom(1024)
        message = bytesAddressPair[0]
        address = bytesAddressPair[1]
        msg = message.decode()
        clientMsg = "{}".format(message)
        clientAddress = "{}".format(address)
        print(msg, clientAddress)
        splitMessage = msg.split(" ")
        command = splitMessage[0]
        print(command)
        if command == "threshold":
            th = splitMessage[1]
            queue.put(th)
        elif command == "standby":
            ReadingData.terminate()
        elif command == "start":
            ReadingData.start()
        else:
            print("bad command")
