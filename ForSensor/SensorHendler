import smbus
import socket
from time import sleep
import multiprocessing

PWR_MGMT_1 = 0x6B
SMPLRT_DIV = 0x19
CONFIG = 0x1A
GYRO_CONFIG = 0x1B
INT_ENABLE = 0x38
ACCEL_XOUT_H = 0x3B
ACCEL_YOUT_H = 0x3D
ACCEL_ZOUT_H = 0x3F
GYRO_XOUT_H = 0x43
GYRO_YOUT_H = 0x45
GYRO_ZOUT_H = 0x47
# bus = smbus.SMBus(1)
Device_Address = 0x68
serverAddressPort = ("127.0.0.1", 20001)
UDPClientSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
bufferSize = 1024
UDPClientSocket.connect(serverAddressPort)
UDPClientSocket.settimeout(5)

def MPU_Init():
    bus.write_byte_data(Device_Address, SMPLRT_DIV, 7)
    bus.write_byte_data(Device_Address, PWR_MGMT_1, 1)
    bus.write_byte_data(Device_Address, CONFIG, 0)
    bus.write_byte_data(Device_Address, GYRO_CONFIG, 24)
    bus.write_byte_data(Device_Address, INT_ENABLE, 1)


def read_raw_data(addr):
    high = bus.read_byte_data(Device_Address, addr)
    low = bus.read_byte_data(Device_Address, addr + 1)
    value = ((high << 8) | low)
    if value > 32768:
        value = value - 65536
    return value


def analyzeData(Queue):
    th = 4
    run = True
    while True:
        if not (Queue.empty()):
            obj = Queue.get()
            if type(obj) == float or type(obj) == int:
                th = obj
            elif type(obj) == bool:
                run = obj
        if run:
            acc_x = read_raw_data(ACCEL_XOUT_H)
            acc_y = read_raw_data(ACCEL_YOUT_H)
            acc_z = read_raw_data(ACCEL_ZOUT_H)
            gyro_x = read_raw_data(GYRO_XOUT_H)
            gyro_y = read_raw_data(GYRO_YOUT_H)
            gyro_z = read_raw_data(GYRO_ZOUT_H)
            Ax = acc_x / 16384.0
            Ay = acc_y / 16384.0
            Az = acc_z / 16384.0

            Gx = gyro_x / 131.0
            Gy = gyro_y / 131.0
            Gz = gyro_z / 131.0
            sleep(1)
            if Ax > th or Ay > th or Az > th or Gx > th or Gy > th or Gz > th:
                alert = str.encode("alert")
                UDPClientSocket.sendto(alert, serverAddressPort)
                try:
                    answer = UDPClientSocket.recvfrom(1024)
                    Message = answer[0].decode().split(" ")
                    print(Message[0])
                except ConnectionError:     # lost connection
                    print("connection lost")
                    continue
                except Exception as e:  # other exceptions
                    print(e)
                    continue
                sleep(20)  # sleep to avoid overloading alerts until waves calm
        else:
            sleep(1)


def receiveMessages():
    while True:
        try:
            bytesAddressPair = UDPClientSocket.recvfrom(1024)
            splitMessage = bytesAddressPair[0].decode().split(" ")
            command = splitMessage[0]
            print(command)
            if command == "threshold":
                queue.put(splitMessage[1])
            elif command == "standby":
                queue.put(False)
            elif command == "start":
                queue.put(True)
            else:
                print(command)
        except socket.timeout:
            pass
        except Exception as exp:
            print(exp)
            pass


if __name__ == '__main__':
    MPU_Init()
    queue = multiprocessing.Queue()
    bytesToSend = str.encode("sensor")
    try:
        UDPClientSocket.sendto(bytesToSend, serverAddressPort)
        ReadingData = multiprocessing.Process(target=analyzeData, args=(queue,))
        ReadingData.start()
        receiveMessages()
    except WindowsError as e:
        print(e)
        print("no connection")
    except Exception as e:
        print(e)
